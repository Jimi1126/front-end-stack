# 什么是 Vue.js？

> 官网：https://cn.vuejs.org/index.html

其实官网已经说的很清楚了，Vue.js 是一个用于创建用户界面的渐进式 JavaScript 框架。

这里的渐进式指的是，Vue.js 可以自底向上逐层应用在用户界面上。

这里对 Vue.js 的核心特性做一次概述，更多细节可以查看官网的介绍。

## 渐进式

Vue.js 是一个渐进式框架，这意味着我们可以从简单的开始使用 Vue.js，然后逐步增加更多的功能和特性。

我们可以用不同的方式使用 Vue：

- 无需构建步骤，渐进式增强静态的 HTML
- 在任何页面中作为 Web Components 嵌入
- 单页应用 (SPA)
- 全栈 / 服务端渲染 (SSR)
- Jamstack / 静态站点生成 (SSG)
- 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面

例如，我们可以在一个简单的 HTML 文件中使用 Vue.js 来渲染一个简单的消息：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Hello World</title>
  </head>
  <body>
    <div id="app">
      <h1>{{ message }}</h1>
      <input type="text" v-model="message" />
      <button @click="sendMessage">send message</button>
    </div>
  </body>
  <script type="module">
    import {
      createApp,
      ref,
    } from 'https://cdn.jsdelivr.net/npm/vue@3.5.11/dist/vue.esm-browser.prod.min.js';

    createApp({
      setup() {
        const message = ref('Hello, Vue.js!');
        const sendMessage = () => {
          alert(message.value);
        };
        return {
          message,
          sendMessage,
        };
      },
    }).mount('#app');
  </script>
</html>
```

## 声明式

### 什么是声明式编程？

要理解 Vue.js 的声明式特性，我们需要先理解什么是声明式编程。

声明式编程是一种编程范式，它允许开发者表达逻辑而无需明确描述控制流。也就是说，我们可以用简洁的代码来描述我们要做什么，而不是如何去做。这种编程方式更接近自然语言，因为它描述了预期的结果，而不是实现这些结果的具体步骤。

声明式编程的特点：

- **简洁性**：代码更简洁，因为不需要编写控制流逻辑。
- **可读性**：代码更易于理解，因为它直接表达了开发者的意图。
- **可维护性**：由于代码的意图清晰，维护和修改也变得更容易。

例如：

在 SQL 中查询数据库就是一个典型的声明式编程的例子。你只需要声明你想要什么数据（SELECT 语句），而不需要告诉数据库如何去获取这些数据（数据库自己会处理）。

### Vue.js 中的声明式

Vue 的声明式特性主要是指声明式渲染。声明式渲染是指 Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。

通过这套模板语法编写的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。

在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。

Vue 的模板语法包括以下核心的特性：

- **插值语法**：可以在模板中插入变量，使用 `{{}}` 语法。
- **指令系统**：Vue 提供了一系列基础指令，使得我们可以声明式的条件渲染、循环渲染和双向数据绑定等。并且支持自定义指令。
- **元素属性约定**：Vue 对 HTML 元素的一些特定属性进行约定，如 key、ref、slot 等。这些约定属性赋予了 Vue 模板语法更多的意义。
- **元素属性绑定**：Vue 对于 HTML 元素属性绑定提供了一系列约定的语法糖，使得我们可以声明式的绑定 HTML 元素的属性。比如类与样式支持对象、数组和函数绑定，属性可用于组件通信，属性穿透到子孙组件等。
- **事件绑定**：Vue 提供了基于 HTML 元素的事件绑定提供了一系列约定的语法糖，使得我们可以声明式的处理事件。比如支持修饰符和按键码的监听器等。
- **插槽**：这允许我们将一个组件的布局结构拆分出来，在父组件中声明子组件的插入位置。并且支持作用域插槽。
- **组件系统**：Vue 提供了组件系统的 API，使得我们可以将界面拆分成一个个小的、可复用的个体。
- **内置组件**：Vue 提供实用的内置组件，从框架层面提供通用的功能，。如 `<transition>`、`<keep-alive>`、`<teleport>`、`<suspense>` 等。

## 组件化

首先我们需要理解什么是组件？组件是描述了 UI 的一部分，组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。例如按钮或复选框。它既可以提高可维护性，也允许代码重用。而多个组件也可以组合成更大的组件。

**Vue 的组件化**：其实就是是对项目进行自上而下的拆分，把通用的、可复用的功能中的模型（Model）、视图（View）和视图模型（ViewModel）以黑盒的形式封装到一个组件中，然后暴露一些开箱即用的函数和属性配置供外部组件调用，实现与业务逻辑的解耦，来达到代码间的高内聚、低耦合，实现功能模块的可配置、可复用、可扩展。除此之外，还可以再由这些组件组合更复杂的组件、页面。

> 注意：组件化 ≠ 模块化。模块化是从文件层面上，对代码或资源进行拆分；而组件化是从设计层面上，对用户界面进行拆分。前端组件化更偏向 UI 层面，更多把逻辑放到页面中，使得 UI 元素复用性更高。

并且 Vue 推荐使用单文件组件，一个 Vue 单文件组件 (SFC)，通常使用 `*.vue` 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。

每一个 `*.vue` 文件都由三种顶层语言块构成：`<template>`、`<script>` 和 `<style>`，以及一些其他的自定义块：

```html
<template>
  <div class="example">{{ msg }}</div>
</template>

<script>
  export default {
    data() {
      return {
        msg: 'Hello world!',
      };
    },
  };
</script>

<style>
  .example {
    color: red;
  }
</style>

<custom1> This could be e.g. documentation for the component. </custom1>
```

**为什么要使用单文件组件**

使用单文件组件必须使用构建工具，但作为回报带来了以下优点：

- 使用熟悉的 HTML、CSS 和 JavaScript 语法编写模块化的组件
- 让本来就强相关的关注点自然内聚
- 预编译模板，避免运行时的编译开销
- 组件作用域的 CSS
- 在使用组合式 API 时语法更简单
- 通过交叉分析模板和逻辑代码能进行更多编译时优化
- 更好的 IDE 支持，提供自动补全和对模板中表达式的类型检查
- 开箱即用的模块热更新 (HMR) 支持

单文件组件是 Vue 框架提供的一个功能，并且在下列场景中都是官方推荐的项目组织方式：

- 单页面应用 (SPA)
- 静态站点生成 (SSG)
- 任何值得引入构建步骤以获得更好的开发体验 (DX) 的项目

## 响应式

什么是响应式？前端的响应式其实是指当数据发生变化时，UI 也会自动更新。Vue.js 的响应式系统让我们的应用数据变化可以驱动视图的变化。这也是为什么说 Vue 是 MVVM 框架的原因。

Vue 的响应式系统很巧妙地利用对象的 setter 和 getter 特性，通过在 getter 进行依赖收集，在 setter 触发更新，从而实现数据变化时发生副作用。

在 Vue2.x 是通过 Object.defineProperty() 实现响应式系统，在 Vue3.x 中使用 ES6 的 Proxy 实现响应式系统。

Vue 的响应式系统提供以下核心部件：

- 响应式 API：Vue.js 提供了一系列的 API，如 ref、reactive、computed 等，使得我们可以声明式地创建响应式数据。
- 响应式工具：Vue.js 提供了一系列的工具函数，如 watch、watchEffect 等，使得我们可以声明式地监听数据变化。
- 副作用：Vue.js 的响应式系统提供了副作用的概念，使得我们可以声明式的处理数据变化时需要执行的操作。

## 选项式

Vue 的选项式 API 是 Vue.js 2.x 中引入的编程范式，它是一种组织 Vue 组件逻辑的方式，它将组件的属性、方法、生命周期钩子等定义在一个选项对象中。这种方式类似于配置一个对象，其中包含了组件的各种配置项。
它的核心设计理念是使用配置对象来创建组件实例。

Vue 的选项式 API 提供以下核心部件：

- data：Vue.js 提供了 data，使得我们可以声明式的定义组件的响应式数据。
- props：Vue.js 提供了 props，使得我们可以声明式的定义组件的对外接口。
- 方法：Vue.js 提供了方法，使得我们可以声明式的处理组件的方法。
- watch 和 computed：Vue.js 提供了 watch 和 computed，使得我们可以声明式的监听和计算数据变化。
- 生命周期钩子：Vue.js 提供了生命周期钩子，使得我们可以声明式的处理组件的生命周期事件。
- components：Vue.js 提供了 components，使得我们可以声明式的定义组件的内部结构。

**选项式 API 的特点：**

- 组织清晰：对于初学者来说，选项式 API 的组织方式直观且易于理解。
- 易于理解：每个选项的作用都很明确，易于学习和使用。
- 适用于小型到中型项目：对于结构不是特别复杂的项目，选项式 API 可以很好地组织代码。

**选项式 API 的局限性：**

- 代码分散：随着组件逻辑的增加，选项式 API 可能导致代码分散在多个选项中，难以维护。
- 难以追踪状态：在复杂的组件中，状态和逻辑的追踪可能变得困难。
- 类型推导困难：在复杂的组件中，类型推导可能变得困难。

## 组合式

Vue 3 引入的组合式 API（Composition API）是一种新的编写组件逻辑的方式，它提供了一种更灵活、更模块化的代码组织方法。组合式 API 允许开发者将组件的响应式状态、计算属性、方法、生命周期钩子等逻辑以函数的形式组织起来，从而使得代码更加灵活和可复用 。

组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了
以下方面的 API：

- **响应式 API**：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。
- **生命周期钩子**：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。
- **依赖注入**：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。

虽然这套 API 的风格是基于函数的组合，但组合式 API 并不是函数式编程。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程通常强调数据不可变。

### 组合式 API 的优势

- **更好的逻辑复用**：
  组合式 API 通过组合函数（Composable functions）实现了逻辑的复用，解决了 mixins 在 Options API 中的缺陷，促进了代码的重用和维护 。

- **更灵活的代码组织**：
  组合式 API 允许开发者将相关的逻辑组合在一起，形成一个可复用的代码块，这使得代码更加模块化，易于理解和维护 。

- **更好的类型推导**：
  对于使用 TypeScript 的开发者，组合式 API 提供了更好的类型推导支持，因为它主要利用基本的变量和函数，这些本身就是类型友好的 。

- **更小的生产包体积**：
  使用组合式 API 和 `<script setup>` 语法的代码更高效，对代码压缩也更友好，因为模板可以直接访问 `<script setup>` 中定义的变量，无需从实例中代理 。

### `组合式 API` vs `选项式 API`

组合式 API 不像选项式 API 那样会手把手教你该把代码放在哪里。但反过来，它却让你可以像编写普通的 JavaScript 那样来编写组件代码。这意味着你能够，并且应该在写组合式 API 的代码时也运用上所有普通 JavaScript 代码组织的最佳实践。如果你可以编写组织良好的 JavaScript，你也应该有能力编写组织良好的组合式 API 代码。

选项式 API 确实允许你在编写组件代码时“少思考”，这是许多用户喜欢它的原因。然而，在减少费神思考的同时，它也将你锁定在规定的代码组织模式中，没有摆脱的余地，这会导致在更大规模的项目中难以进行重构或提高代码质量。在这方面，组合式 API 提供了更好的长期可维护性。

### 组合式函数（Hook）

在 Vue 应用的概念中，“组合式函数”(Composables) 是**一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数**。

当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间，我们可能会抽取一个可复用的日期格式化函数。这个函数封装了无状态的逻辑：它在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，比如你可能已经用过的 lodash 或是 date-fns。

相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。

**约定和最佳实践**

- 命名：组合式函数应该以 `use` 开头，表明它们是可复用的。
- 参数：组合式函数接收任意数量的参数，并且应该使用解构来获取它们。
- 副作用：组合式函数应该避免直接修改传入的参数，而是应该返回一个包含副作用的函数。
- 返回值：组合式函数应该返回一个包含副作用的函数，或者直接修改传入的参数。
- 组合式函数只能在 `<script setup>` 或 `setup()` 钩子中被调用。

**与 Mixin 的对比**

mixins 也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：

- **不清晰的数据来源**：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。
- **命名空间冲突**：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。
- **隐式的跨 mixin 交流**：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。

## 虚拟 DOM

[todo]

---

- 渐进式：Vue.js 可以自底向上逐层应用在用户界面上。
- 声明式：Vue.js 提供了声明式的 API，使得我们可以用简洁的 API 来表达复杂的逻辑。
- 组件化：Vue.js 提供了丰富的组件，使得我们可以将界面拆分成一个个小的、可复用的个体。
- 响应式：Vue.js 的核心是一个响应系统，它让我们的应用数据变化可以驱动视图的变化。
- 组合式 API：Vue.js 提供了组合式 API，使得我们可以更灵活地组织代码和复用逻辑。
- 虚拟 DOM：Vue.js 使用虚拟 DOM 来驱动视图，使得我们可以更高效地计算出极小范围值得更新。
- 工具化：Vue.js 提供了一整套构建工具，使得我们可以更高效地开发应用。
- 社区化：Vue.js 有非常活跃的社区，并且有很多第三方工具和资源可供我们使用。
- 生态化：Vue.js 的生态系统非常庞大，并且不断增长。
- 性能化：Vue.js 的核心是一个高性能的响应系统，使得我们可以更高效地驱动视图。
- 轻量级：Vue.js 的核心库只有 30kb，并且可以很容易地与其他库或现有项目进行整合。
- 跨平台：Vue.js 可以运行在浏览器、服务器端和移动设备上，并且支持多种构建工具和部署流程。
- 标准化：Vue.js 的核心规范非常清晰，并且已经得到了广泛的应用和认可。
- 文档化：Vue.js 的官方文档非常详细，并且提供了大量的示例和教程。
- 国际化：Vue.js 支持多种语言和地区，并且可以很容易地扩展支持其他语言。
- 安全性：Vue.js 提供了多种安全措施，使得我们可以更安全地使用 Vue.js。
- 健壮性：Vue.js 的核心库非常稳定，并且已经得到了广泛的应用和测试。
